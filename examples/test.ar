/* Maybe Data Type
*/
data Maybe<a> = Some(a) | None;

let bindMaybe : Maybe<a> -> (a -> Maybe<b>) -> Maybe<b> = fn(m, f) =>
    match m with
        Some(a) -> f(a),
        None -> None;

let (?>>=) = bindMaybe;
let (?>=>) : (a -> Maybe<b>) -> (b -> Maybe<c>) -> a -> Maybe<c>
    = fn(f, g, x) => f(x) ?>>= g;

/* Either Data Type
*/
data Either<a, b> = Left(a) | Right(b);

let bindEither : Either<a, b> -> (b -> Either<c, d>) -> Either<c, d>
    = fn(m, f) =>
        match m with
            Left(l) -> Left(l),
            Right(r) -> f(r);

let leftToMaybe : Either<a, b> -> Maybe<a> = fn(e) =>
    match e with
        Left(l) -> Some(l),
        Right(r_) -> None;

/* List Data Type
*/ 
data List<a> = Elem(a, List<a>) | Empty;

let map : (a -> b) -> List<a> -> List<b> = fn(f, list) =>
    match list with
        Elem(a, list') ->
            Elem(f(a), map(f, list')),
        Empty -> Empty;

let fold : (a -> b -> b) -> List<a> -> b -> b = fn(f, list, a) =>
    match list with
        Elem(a', list') ->
            f(a', fold(f, list', a)),
        Empty -> a;

let (++) : List<a> -> List<a> -> List<a> = fn(l1, l2) =>
    match l1 with
        Elem(a, l1') -> Elem(a, l1' ++ l2),
        Empty -> l2;

let safeHead : List<a> -> Maybe<a> = fn(l) =>
    match l with
        Elem(a, l_) -> Some(a),
        Empty -> None;

let head : List<a> -> a = fn(l) =>
    match l with
        Elem(a, l_) -> a,
        Empty -> error("head: empty list");

let tail : List<a> -> List<a> = fn(l) =>
    match l with
        Elem(a_, l) -> l,
        Empty -> error ("tail: empty list");

let last : List<a> -> a = fn(l) =>
    match l with
        Elem(a, Empty) -> a,
        Elem(a_, l') -> last(l'),
        Empty -> error("last: empty list");

let test = Elem(last("epic"), Empty);
print(test);
